{"version":3,"file":"yt.min.js","sources":["../../src/player/yt.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Youtube Player class\n * Documented at https://developers.google.com/youtube/iframe_api_reference\n *\n * @module     mod_interactivevideo/player/yt\n * @copyright  2024 Sokunthearith Makara <sokunthearithmakara@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {dispatchEvent} from 'core/event_dispatcher';\nimport $ from 'jquery';\nimport allowAutoplay from 'mod_interactivevideo/player/checkautoplay';\n\nlet player = {};\nclass Yt {\n    /**\n     * Creates an instance of the YouTube player.\n     *\n     * @constructor\n     */\n    constructor() {\n        this.useAnimationFrame = true;\n        /**\n         * The type of the player\n         * @type {String}\n         * @default yt\n         * @private\n         * @readonly\n         */\n        this.type = 'yt';\n        /**\n         * Interval frequency\n         * @type {Number}\n         */\n        this.frequency = 0.25;\n        this.support = {\n            playbackrate: true,\n            quality: false,\n            password: true,\n        };\n        this.live = false; // Added flag for live video support\n    }\n    /**\n     * Get information about the video\n     * @param {string} url\n     * @param {string} node\n     * @return {Promise<Object>}\n     */\n    async getInfo(url, node) {\n        this.node = node;\n        return new Promise((resolve) => {\n            var YT;\n            let regex = new RegExp(\n                '(?:https?:\\\\/\\\\/)?' +\n                '(?:www\\\\.)?' +\n                '(?:youtube\\\\.com|youtu\\\\.be|youtube-nocookie\\\\.com)' +\n                '(?:\\\\/embed\\\\/|\\\\/watch\\\\?v=|\\\\/)([^\\\\/]+)',\n                'g'\n            );\n            var match = regex.exec(url);\n            var videoId = match[1];\n            videoId = videoId.split(\"&\")[0];\n            var options = {\n                videoId: videoId,\n                width: 1080,\n                height: 720,\n                playerVars: {\n                    autoplay: 0,\n                    hl: M.cfg.language,\n                    controls: 1,\n                    showinfo: 0,\n                    fs: 0,\n                    \"iv_load_policy\": 3,\n                    \"cc_load_policy\": 0,\n                    autohide: 1,\n                    rel: 0,\n                    playsinline: 1,\n                    disablekb: 0,\n                },\n                events: {\n                    onReady: function(e) {\n                        resolve({\n                            title: e.target.videoTitle,\n                            duration: e.target.getDuration(),\n                            posterImage: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,\n                        });\n                    },\n                }\n            };\n            if (!window.YT) {\n                var tag = document.createElement('script');\n                tag.src = \"https://www.youtube.com/iframe_api\";\n                tag.async = true;\n                tag.as = \"script\";\n                tag.rel = \"preload\";\n                var firstScriptTag = document.getElementsByTagName('script')[0];\n                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n                // Replace the 'player' element with an <iframe> and YouTube player\n                window.onYouTubeIframeAPIReady = function() {\n                    YT = window.YT || {};\n                    player[node] = new YT.Player(node, options);\n                };\n            } else {\n                YT = window.YT || {};\n                player[node] = new YT.Player(node, options);\n            }\n        });\n    }\n    /**\n     * Load the video\n     * @param {string} url\n     * @param {number} start\n     * @param {number} end\n     * @param {object} opts\n     * @param {boolean} reloaded\n     * @return {Promise<Boolean>}\n     */\n    async load(url, start, end, opts = {}, reloaded = false) {\n        const showControls = opts.showControls || false;\n        const customStart = opts.customStart || false;\n        const preload = opts.preload || false;\n        const node = opts.node || 'player';\n        this.node = node;\n\n        // Hide the player first.\n        this.allowAutoplay = await allowAutoplay(document.getElementById(node));\n        if (!this.allowAutoplay) {\n            dispatchEvent('iv:autoplayBlocked', {\n                requireVideoBlock: true,\n            });\n        }\n        /**\n         * The start time of the video\n         * @type {Number}\n         * @private\n         */\n        this.start = start;\n        /**\n         * The end time of the video\n         * @type {Number}\n         */\n        this.end = end;\n        var YT;\n        let regex = new RegExp(\n            '(?:https?:\\\\/\\\\/)?' +\n            '(?:www\\\\.)?' +\n            '(?:youtube\\\\.com|youtu\\\\.be|youtube-nocookie\\\\.com)' +\n            '(?:\\\\/embed\\\\/|\\\\/watch\\\\?v=|\\\\/)([^\\\\/]+)',\n            'g'\n        );\n        var match = regex.exec(url);\n        var videoId = match[1];\n        videoId = videoId.split(\"&\")[0];\n        this.videoId = videoId;\n        this.posterImage = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;\n        // If the img size is 90x120, it means the maxresdefault.jpg is not available. So we use hqdefault.jpg instead.\n        const img = new Image();\n        img.src = this.posterImage;\n        img.onload = () => {\n            if (img.width == 120 && img.height == 90) {\n                this.posterImage = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;\n            }\n        };\n\n        let loadedcaption = false;\n        var ready = false;\n        var self = this;\n        let hasError = false;\n        var options = {\n            videoId: videoId,\n            width: 1080,\n            height: 720,\n            playerVars: {\n                autoplay: opts.autoplay || 0,\n                hl: M.cfg.language,\n                start: start,\n                end: end,\n                controls: showControls ? 1 : 0,\n                showinfo: 0,\n                fs: 0,\n                \"iv_load_policy\": 3,\n                \"cc_load_policy\": 0,\n                autohide: 1,\n                rel: 0,\n                playsinline: 1,\n                disablekb: opts.keyboard ? 0 : 1,\n                mute: 1,\n            },\n            events: {\n                onError: function(e) {\n                    hasError = true;\n                    dispatchEvent('iv:playerError', {error: e.data});\n                },\n                onReady: function(e) {\n                    self.title = e.target.videoTitle;\n                    // We don't want to use the end time from the player, just to avoid any issue restarting the video.\n                    if (e.target.getDuration() <= 0 && e.target.videoTitle == '') {\n                        dispatchEvent('iv:playerError', {error: 'Video not found'});\n                        return;\n                    }\n                    let totaltime = Number(e.target.getDuration().toFixed(2)) - self.frequency;\n                    if (e.target.getDuration() == 0) {\n                        totaltime = 0.1;\n                        self.live = true;\n                    }\n                    if (end == 0.1 && !self.live) {\n                        end = totaltime;\n                    }\n                    end = !end ? totaltime : Math.min(end, totaltime);\n                    end = Number(end.toFixed(2));\n                    self.end = end;\n                    self.totaltime = totaltime;\n                    self.duration = self.end - self.start;\n                    self.aspectratio = self.ratio();\n                    // It's always good idea to play the video at the beginning to download some data.\n                    // Otherwise, if user seek before start, they're gonna get blackscreen.\n                    if (preload == true && customStart == false) { // For editing form\n                        ready = true;\n                        dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                        $(`#video-wrapper`).removeClass('invisible');\n                    } else {\n                        e.target.mute();\n                        e.target.playVideo();\n                        let count = 0;\n                        let interval = setInterval(() => {\n                            count++;\n                            if (ready === true) {\n                                clearInterval(interval);\n                                e.target.pauseVideo();\n                                e.target.unMute();\n                                return;\n                            }\n                            let currentTime = e.target.getCurrentTime();\n                            if (currentTime > 0 || count > 6) {\n                                clearInterval(interval);\n                                if (hasError) {\n                                    return;\n                                }\n                                if (self.live) {\n                                    self.start = currentTime;\n                                    self.end = currentTime + 1;\n                                }\n                                if (Math.abs(currentTime - self.start) > self.frequency) {\n                                    e.target.seekTo(self.start);\n                                }\n\n                                if (e.target.getPlayerState() === YT.PlayerState.BUFFERING) {\n                                    e.target.playVideo();\n                                    setTimeout(() => {\n                                        e.target.unMute();\n                                        ready = true;\n                                        dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                                    }, 1000);\n                                } else {\n                                    e.target.unMute();\n                                    ready = true;\n                                    dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                                }\n                                $(`#video-wrapper`).removeClass('invisible');\n                            }\n                        }, 1000);\n                    }\n                },\n\n                onAutoplayBlocked: function(e) {\n                    $(`.video-block, #video-block`).remove();\n                    if (ready === false) {\n                        e.target.unMute();\n                        ready = true;\n                        dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                        $(`#video-wrapper`).removeClass('invisible');\n                    }\n                },\n\n                onStateChange: function(e) {\n                    if (ready === false) {\n                        return;\n                    }\n                    let currentTime = player[self.node].getCurrentTime();\n                    // For non-live videos, enforce start/end boundaries\n                    if (!self.live) {\n                        if (currentTime < self.start) {\n                            player[self.node].seekTo(self.start);\n                            player[self.node].playVideo();\n                        }\n                        if (currentTime >= self.end + self.frequency) {\n                            player[self.node].seekTo(self.end - self.frequency);\n                            player[self.node].playVideo();\n                        }\n                    }\n                    switch (e.data) {\n                        case YT.PlayerState.ENDED:\n                            self.ended = true;\n                            self.paused = true;\n                            dispatchEvent('iv:playerEnded');\n                            break;\n                        case YT.PlayerState.PLAYING:\n                            self.paused = false;\n                            if (self.ended) {\n                                self.ended = false;\n                                if (currentTime < self.start) {\n                                    player[self.node].seekTo(self.start);\n                                } else if (currentTime >= self.end) {\n                                    player[self.node].seekTo(self.start);\n                                }\n                            }\n                            dispatchEvent('iv:playerPlay');\n                            dispatchEvent('iv:playerPlaying');\n                            if (!self.live && currentTime >= self.end) {\n                                self.ended = true;\n                                self.paused = true;\n                                dispatchEvent('iv:playerEnded');\n                            }\n                            break;\n                        case YT.PlayerState.PAUSED:\n                            self.paused = true;\n                            dispatchEvent('iv:playerPaused');\n                            break;\n                        case YT.PlayerState.CUED:\n                            if (!self.live && currentTime >= self.end) {\n                                player[self.node].seekTo(self.start);\n                            }\n                            break;\n                    }\n                },\n\n                onPlaybackRateChange: function(e) {\n                    dispatchEvent('iv:playerRateChange', {rate: e.data});\n                },\n\n                onApiChange: function() {\n                    // Always load captions\n                    if (!loadedcaption) {\n                        player[self.node].loadModule('captions');\n                        loadedcaption = true;\n                    }\n                    player[self.node].setOption('captions', 'track', {});\n\n                    let tracks;\n                    try {\n                        tracks = player[self.node].getOption('captions', 'tracklist');\n                    } catch (e) {\n                        tracks = [];\n                    }\n                    if (tracks && tracks.length > 0) {\n                        // Set the first track as active.\n                        tracks = tracks.map((track) => {\n                            return {\n                                label: track.displayName,\n                                code: track.languageCode,\n                            };\n                        });\n                        self.captions = tracks;\n                    }\n                    loadedcaption = true;\n                    dispatchEvent('iv:playerLoaded', {tracks, reloaded: reloaded});\n                },\n            }\n        };\n\n        if (url.includes('youtube-nocookie')) {\n            options.host = 'https://www.youtube-nocookie.com';\n        }\n        // Load the IFrame Player API code asynchronously.\n        if (!window.YT) {\n            var tag = document.createElement('script');\n            tag.src = \"https://www.youtube.com/iframe_api\";\n            tag.async = true;\n            tag.as = \"script\";\n            tag.rel = \"preload\";\n            var firstScriptTag = document.getElementsByTagName('script')[0];\n            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n            // Replace the 'player' element with an <iframe> and YouTube player\n            window.onYouTubeIframeAPIReady = function() {\n                YT = window.YT || {};\n                player[node] = new YT.Player(node, options);\n            };\n        } else {\n            YT = window.YT || {};\n            player[node] = new YT.Player(node, options);\n        }\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * Play the video\n     * @return {Void}\n     */\n    play() {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].playVideo();\n        this.paused = false;\n    }\n    /**\n     * Pause the video\n     * @return {Void}\n     */\n    pause() {\n        if (!player[this.node]) {\n            return;\n        }\n        if (this.paused) {\n            return;\n        }\n        player[this.node].pauseVideo();\n        this.paused = true;\n    }\n    /**\n     * Stop the video\n     * @param {Number} starttime\n     * @return {Void}\n     */\n    stop(starttime) {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].seekTo(starttime);\n        player[this.node].pauseVideo();\n    }\n    /**\n     * Seek the video to a specific time\n     * @param {Number} time\n     * @return {Promise<Boolean>}\n     */\n    async seek(time) {\n        if (!player[this.node]) {\n            return false;\n        }\n        let currentTime = this.getCurrentTime();\n        if (currentTime === time) {\n            return true;\n        }\n        dispatchEvent('iv:playerSeekStart', {time: currentTime});\n        this.ended = false;\n        return new Promise((resolve) => {\n            player[this.node].seekTo(time, true);\n            dispatchEvent('iv:playerSeek', {time: time});\n            resolve(true);\n        });\n    }\n    /**\n     * Get the current time of the video\n     * @return {Number}\n     */\n    getCurrentTime() {\n        if (!player[this.node]) {\n            return 0;\n        }\n        return player[this.node].getCurrentTime();\n    }\n    /**\n     * Get the duration of the video\n     * @return {Number}\n     */\n    getDuration() {\n        if (!player[this.node]) {\n            return 0;\n        }\n        return player[this.node].getDuration();\n    }\n    /**\n     * Check if the video is paused\n     * @return {Boolean}\n     */\n    isPaused() {\n        if (!player[this.node]) {\n            return true;\n        }\n        if (this.paused) {\n            return true;\n        }\n        return player[this.node].getPlayerState() == window.YT.PlayerState.PAUSED;\n    }\n    /**\n     * Check if the video is playing\n     * @return {Boolean}\n     */\n    isPlaying() {\n        if (!player[this.node]) {\n            return false;\n        }\n        if (this.paused) {\n            return false;\n        }\n        try {\n            return player[this.node].getPlayerState() == window.YT.PlayerState.PLAYING;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Check if the video is ended\n     * @return {Boolean}\n     */\n    isEnded() {\n        if (!player[this.node]) {\n            return false;\n        }\n        if (this.ended) {\n            return true;\n        }\n        return player[this.node].getPlayerState() == window.YT.PlayerState.ENDED || player[this.node].getCurrentTime() >= this.end;\n    }\n    /**\n     * Get the aspect ratio of the video\n     * @return {Number}\n     */\n    ratio() {\n        return 16 / 9; // YT always return 16:9 as of 2024.\n    }\n    /**\n     * Destroy the player\n     * @return {Void}\n     */\n    destroy() {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].destroy();\n        dispatchEvent('iv:playerDestroyed');\n    }\n    /**\n     * Get the state of the player\n     * @return {Number}\n     */\n    getState() {\n        if (!player[this.node]) {\n            return 0;\n        }\n        return player[this.node].getPlayerState();\n    }\n    /**\n     * Set playback rate of the video\n     * @param {Number} rate\n     */\n    setRate(rate) {\n        if (!player[this.node]) {\n            return 1;\n        }\n        player[this.node].setPlaybackRate(rate);\n        return rate;\n    }\n    /**\n     * Mute the video\n     */\n    mute() {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].mute();\n        dispatchEvent('iv:playerVolumeChange', {volume: 0});\n    }\n    /**\n     * Unmute the video\n     */\n    unMute() {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].unMute();\n        player[this.node].setVolume(100);\n        dispatchEvent('iv:playerVolumeChange', {volume: 1});\n    }\n\n    isMuted() {\n        if (!player[this.node]) {\n            return false;\n        }\n        return player[this.node].isMuted();\n    }\n    /**\n     * Get the original player object\n     */\n    originalPlayer() {\n        return player[this.node];\n    }\n\n    /**\n     * Set subtitle\n     * @param {string} track language code\n     */\n    setCaption(track) {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].setOption('captions', 'track', track ? {languageCode: track} : {});\n    }\n}\n\nexport default Yt;"],"names":["player","constructor","useAnimationFrame","type","frequency","support","playbackrate","quality","password","live","url","node","Promise","resolve","YT","videoId","RegExp","exec","options","split","width","height","playerVars","autoplay","hl","M","cfg","language","controls","showinfo","fs","autohide","rel","playsinline","disablekb","events","onReady","e","title","target","videoTitle","duration","getDuration","posterImage","window","Player","tag","document","createElement","src","async","as","firstScriptTag","getElementsByTagName","parentNode","insertBefore","onYouTubeIframeAPIReady","start","end","opts","reloaded","showControls","customStart","preload","allowAutoplay","getElementById","this","requireVideoBlock","img","Image","onload","loadedcaption","ready","self","hasError","keyboard","mute","onError","error","data","totaltime","Number","toFixed","Math","min","aspectratio","ratio","removeClass","playVideo","count","interval","setInterval","clearInterval","pauseVideo","unMute","currentTime","getCurrentTime","abs","seekTo","getPlayerState","PlayerState","BUFFERING","setTimeout","onAutoplayBlocked","remove","onStateChange","ENDED","ended","paused","PLAYING","PAUSED","CUED","onPlaybackRateChange","rate","onApiChange","tracks","loadModule","setOption","getOption","length","map","track","label","displayName","code","languageCode","captions","includes","host","play","pause","stop","starttime","time","isPaused","isPlaying","isEnded","destroy","getState","setRate","setPlaybackRate","volume","setVolume","isMuted","originalPlayer","setCaption"],"mappings":"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"}