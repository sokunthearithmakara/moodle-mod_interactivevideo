{"version":3,"file":"yt.min.js","sources":["../../src/player/yt.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Youtube Player class\n *\n * @module     mod_interactivevideo/player/yt\n * @copyright  2024 Sokunthearith Makara <sokunthearithmakara@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {dispatchEvent} from 'core/event_dispatcher';\nlet player;\nclass Yt {\n    /**\n     * Creates an instance of the YouTube player.\n     *\n     * @constructor\n     */\n    constructor() {\n        this.useAnimationFrame = true;\n        /**\n         * The type of the player\n         * @type {String}\n         * @default yt\n         * @private\n         * @readonly\n         */\n        this.type = 'yt';\n        /**\n         * Interval frequency\n         * @type {Number}\n         */\n        this.frequency = 0.25;\n        this.support = {\n            playbackrate: true,\n            quality: false,\n            password: false,\n        };\n    }\n    /**\n     * Load the video\n     * @param {string} url\n     * @param {number} start\n     * @param {number} end\n     * @param {object} opts\n     * @return {Promise<Boolean>}\n     */\n    load(url, start, end, opts = {}) {\n        const showControls = opts.showControls || false;\n        const customStart = opts.customStart || false;\n        const preload = opts.preload || false;\n        const node = opts.node || 'player';\n        /**\n         * The start time of the video\n         * @type {Number}\n         * @private\n         */\n        this.start = start;\n        /**\n         * The end time of the video\n         * @type {Number}\n         */\n        this.end = end;\n        // Documented at https://developers.google.com/youtube/iframe_api_reference\n        var YT;\n        let regex = new RegExp(\n            '(?:https?:\\\\/\\\\/)?' +\n            '(?:www\\\\.)?' +\n            '(?:youtube\\\\.com|youtu\\\\.be|youtube-nocookie\\\\.com)' +\n            '(?:\\\\/embed\\\\/|\\\\/watch\\\\?v=|\\\\/)([^\\\\/]+)',\n            'g'\n        );\n        var match = regex.exec(url);\n        var videoId = match[1];\n        videoId = videoId.split(\"&\")[0];\n        this.videoId = videoId;\n        this.posterImage = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;\n        let loadedcaption = false;\n        var ready = false;\n        var self = this;\n        var options = {\n            videoId: videoId,\n            width: 1080,\n            height: 720,\n            playerVars: {\n                autoplay: opts.autoplay || 0,\n                hl: M.cfg.language,\n                start: start,\n                end: end,\n                controls: showControls ? 1 : 0,\n                showinfo: 0,\n                fs: 0,\n                iv_load_policy: 3,\n                cc_load_policy: 0,\n                autohide: 1,\n                rel: 0,\n                playsinline: 1,\n                disablekb: 1,\n                mute: 0,\n            },\n            events: {\n                onError: function(e) {\n                    dispatchEvent('iv:playerError', {error: e.data});\n                },\n                onReady: function(e) {\n                    self.title = e.target.videoTitle;\n                    // We don't want to use the end time from the player, just to avoid any issue restarting the video.\n                    let totaltime = Number(e.target.getDuration().toFixed(2)) - self.frequency;\n                    end = !end ? totaltime : Math.min(end, totaltime);\n                    end = Number(end.toFixed(2));\n                    self.end = end;\n                    self.totaltime = totaltime;\n                    self.duration = self.end - self.start;\n                    self.aspectratio = self.ratio();\n                    // It's always good idea to play the video at the beginning to download some data.\n                    // Otherwise, if user seek before start, they're gonna get blackscreen.\n                    if (preload == true && customStart == false) {\n                        ready = true;\n                        dispatchEvent('iv:playerReady');\n                    } else {\n                        e.target.mute();\n                        e.target.playVideo();\n                        let interval = setInterval(() => {\n                            if (e.target.getCurrentTime() > 0) {\n                                clearInterval(interval);\n                                e.target.seekTo(self.start);\n                                e.target.pauseVideo();\n                                e.target.unMute();\n                                ready = true;\n                                dispatchEvent('iv:playerReady');\n                            }\n                        }, 1000);\n                    }\n                },\n\n                onStateChange: function(e) {\n                    if (ready === false) {\n                        return;\n                    }\n                    if (player.getCurrentTime() < self.start) {\n                        player.seekTo(self.start);\n                        player.playVideo();\n                    }\n                    if (player.getCurrentTime() >= self.end + self.frequency) {\n                        player.seekTo(self.end - self.frequency);\n                        player.playVideo();\n                    }\n                    switch (e.data) {\n                        case YT.PlayerState.ENDED:\n                            self.ended = true;\n                            self.paused = true;\n                            dispatchEvent('iv:playerEnded');\n                            break;\n                        case YT.PlayerState.PLAYING:\n                            self.paused = false;\n                            if (self.ended) {\n                                self.ended = false;\n                                if (player.getCurrentTime() < self.start) {\n                                    player.seekTo(self.start);\n                                } else if (player.getCurrentTime() >= self.end) {\n                                    player.seekTo(self.start);\n                                }\n                            }\n                            dispatchEvent('iv:playerPlaying');\n                            if (player.getCurrentTime() >= self.end) {\n                                self.ended = true;\n                                self.paused = true;\n                                dispatchEvent('iv:playerEnded');\n                            }\n                            break;\n                        case YT.PlayerState.PAUSED:\n                            self.paused = true;\n                            dispatchEvent('iv:playerPaused');\n                            break;\n                        case YT.PlayerState.CUED:\n                            if (player.getCurrentTime() >= self.end) {\n                                player.seekTo(self.start);\n                            }\n                            break;\n                    }\n                },\n\n                onPlaybackRateChange: function(e) {\n                    dispatchEvent('iv:playerRateChange', {rate: e.data});\n                },\n\n                onApiChange: function() {\n                    // Always load captions\n                    if (!loadedcaption) {\n                        player.loadModule('captions');\n                        loadedcaption = true;\n                    }\n                    player.setOption('captions', 'track', {});\n\n                    let tracks;\n                    try {\n                        tracks = player.getOption('captions', 'tracklist');\n                    } catch (e) {\n                        tracks = [];\n                    }\n                    if (tracks && tracks.length > 0) {\n                        // Set the first track as active.\n                        tracks = tracks.map((track) => {\n                            return {\n                                label: track.displayName,\n                                code: track.languageCode,\n                            };\n                        });\n                        self.captions = tracks;\n                    }\n                    loadedcaption = true;\n                    dispatchEvent('iv:playerLoaded', {tracks});\n                },\n            }\n        };\n\n        if (url.includes('youtube-nocookie')) {\n            options.host = 'https://www.youtube-nocookie.com';\n        }\n        // Load the IFrame Player API code asynchronously.\n        if (!window.YT) {\n            var tag = document.createElement('script');\n            tag.src = \"https://www.youtube.com/iframe_api\";\n            tag.async = true;\n            tag.as = \"script\";\n            tag.rel = \"preload\";\n            var firstScriptTag = document.getElementsByTagName('script')[0];\n            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n            // Replace the 'player' element with an <iframe> and YouTube player\n            window.onYouTubeIframeAPIReady = function() {\n                YT = window.YT || {};\n                player = new YT.Player(node, options);\n            };\n        } else {\n            YT = window.YT || {};\n            player = new YT.Player(node, options);\n        }\n        return new Promise((resolve) => {\n            resolve(true);\n        });\n    }\n    /**\n     * Play the video\n     * @return {Void}\n     */\n    play() {\n        player.playVideo();\n        this.paused = false;\n    }\n    /**\n     * Pause the video\n     * @return {Void}\n     */\n    pause() {\n        player.pauseVideo();\n        this.paused = true;\n        return true;\n    }\n    /**\n     * Stop the video\n     * @param {Number} starttime\n     * @return {Void}\n     */\n    stop(starttime) {\n        player.seekTo(starttime);\n        player.pauseVideo();\n    }\n    /**\n     * Seek the video to a specific time\n     * @param {Number} time\n     * @return {Promise<Boolean>}\n     */\n    async seek(time) {\n        return new Promise((resolve) => {\n            player.seekTo(time, true);\n            dispatchEvent('iv:playerSeek', {time: time});\n            resolve(true);\n        });\n    }\n    /**\n     * Get the current time of the video\n     * @return {Number}\n     */\n    getCurrentTime() {\n        return player.getCurrentTime();\n    }\n    /**\n     * Get the duration of the video\n     * @return {Number}\n     */\n    getDuration() {\n        return player.getDuration();\n    }\n    /**\n     * Check if the video is paused\n     * @return {Boolean}\n     */\n    isPaused() {\n        if (this.paused) {\n            return true;\n        }\n        return player.getPlayerState() == window.YT.PlayerState.PAUSED;\n    }\n    /**\n     * Check if the video is playing\n     * @return {Boolean}\n     */\n    isPlaying() {\n        if (this.paused) {\n            return false;\n        }\n        return player.getPlayerState() == window.YT.PlayerState.PLAYING;\n    }\n    /**\n     * Check if the video is ended\n     * @return {Boolean}\n     */\n    isEnded() {\n        if (this.ended) {\n            return true;\n        }\n        return player.getPlayerState() == window.YT.PlayerState.ENDED || player.getCurrentTime() >= this.end;\n    }\n    /**\n     * Get the aspect ratio of the video\n     * @return {Number}\n     */\n    ratio() {\n        return 16 / 9; // YT always return 16:9 as of 2024.\n    }\n    /**\n     * Destroy the player\n     * @return {Void}\n     */\n    destroy() {\n        player.destroy();\n        dispatchEvent('iv:playerDestroyed');\n    }\n    /**\n     * Get the state of the player\n     * @return {Number}\n     */\n    getState() {\n        return player.getPlayerState();\n    }\n    /**\n     * Set playback rate of the video\n     * @param {Number} rate\n     */\n    setRate(rate) {\n        player.setPlaybackRate(rate);\n        return rate;\n    }\n    /**\n     * Mute the video\n     */\n    mute() {\n        player.mute();\n    }\n    /**\n     * Unmute the video\n     */\n    unMute() {\n        player.unMute();\n    }\n    /**\n     * Get the original player object\n     */\n    originalPlayer() {\n        return player;\n    }\n\n    /**\n     * Set subtitle\n     * @param {string} track language code\n     */\n    setCaption(track) {\n        player.setOption('captions', 'track', track ? {languageCode: track} : {});\n    }\n}\n\nexport default Yt;"],"names":["player","constructor","useAnimationFrame","type","frequency","support","playbackrate","quality","password","load","url","start","end","opts","showControls","customStart","preload","node","YT","videoId","RegExp","exec","split","posterImage","loadedcaption","ready","self","this","options","width","height","playerVars","autoplay","hl","M","cfg","language","controls","showinfo","fs","iv_load_policy","cc_load_policy","autohide","rel","playsinline","disablekb","mute","events","onError","e","error","data","onReady","title","target","videoTitle","totaltime","Number","getDuration","toFixed","Math","min","duration","aspectratio","ratio","playVideo","interval","setInterval","getCurrentTime","clearInterval","seekTo","pauseVideo","unMute","onStateChange","PlayerState","ENDED","ended","paused","PLAYING","PAUSED","CUED","onPlaybackRateChange","rate","onApiChange","tracks","loadModule","setOption","getOption","length","map","track","label","displayName","code","languageCode","captions","includes","host","window","Player","tag","document","createElement","src","async","as","firstScriptTag","getElementsByTagName","parentNode","insertBefore","onYouTubeIframeAPIReady","Promise","resolve","play","pause","stop","starttime","time","isPaused","getPlayerState","isPlaying","isEnded","destroy","getState","setRate","setPlaybackRate","originalPlayer","setCaption"],"mappings":"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"}