{"version":3,"file":"html5video.min.js","sources":["../../src/player/html5video.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * HTML5 Video Player class\n * Documentation for DASH.js: https://reference.dashif.org/dash.js/v4.4.0/samples/index.html\n * Documentation for HLS.js: https://github.com/video-dev/hls.js\n * @module     mod_interactivevideo/player/html5video\n * @copyright  2024 Sokunthearith Makara <sokunthearithmakara@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {dispatchEvent} from 'core/event_dispatcher';\nimport allowAutoplay from 'mod_interactivevideo/player/checkautoplay';\n\nclass Html5Video {\n    /**\n     * Constructor for the HTML5 video player.\n     */\n    constructor() {\n        this.type = \"html5video\";\n        this.frequency = 0.4;\n        this.useAnimationFrame = false;\n        this.support = {\n            playbackrate: true,\n            quality: true,\n        };\n    }\n    /**\n     * Loads an instance of an HTML5 video player.\n     *\n     * @param {string} url - The URL of the video to be played.\n     * @param {number} start - The start time of the video in seconds.\n     * @param {number} [end] - The end time of the video in seconds. If not provided, defaults to the video's duration.\n     * @param {object} opts - The options for the player.\n     */\n    async load(url, start, end, opts = {}) {\n        const showControls = opts.showControls || false;\n        const node = opts.node || 'player';\n        const autoplay = opts.autoplay || false;\n        this.start = start;\n        this.end = end;\n        this.allowAutoplay = await allowAutoplay(document.getElementById(node));\n        if (!this.allowAutoplay) {\n            dispatchEvent('iv:autoplayBlocked', {\n                requireVideoBlock: true\n            });\n        }\n        var player = document.getElementById(node);\n        this.posterImage = player.poster;\n        // Check if the url is for video or audio.\n        const video = ['fmp4', 'm4v', 'mov', 'mp4', 'ogv', 'webm', 'mkv', 'avi', 'flv', 'wmv', 'm3u8', 'mpd'];\n        const ext = url.split('.').pop();\n        if (video.indexOf(ext) === -1) {\n            // Change the player to an audio player.\n            this.audio = true;\n            // Append a canvas element to the video.\n            const canvas = '<canvas id=\"visualizer\"></canvas>';\n            player.insertAdjacentHTML('afterend', canvas);\n            player.style.visibility = 'hidden';\n        }\n        // Determine video type based on file extension.\n        if (url.indexOf('.m3u8') !== -1) {\n            let Hls = await import('mod_interactivevideo/player/hls');\n            // Handle HLS stream.\n            if (typeof Hls !== 'undefined' && Hls.isSupported()) {\n                var hls = new Hls();\n                hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {\n                    this.support.quality = true;\n                    this.hlsdata = data;\n                });\n\n                hls.loadSource(url);\n                // Bind them together.\n                hls.attachMedia(player);\n\n                // Handle quality change.\n                hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {\n                    dispatchEvent('iv:playerQualityChange', {quality: data.level});\n                });\n\n                hls.on(Hls.Events.ERROR, function(event, data) {\n                    if (data.fatal) {\n                        dispatchEvent('iv:playerError', {error: data});\n                    }\n                });\n\n                this.hls = hls;\n            } else if (player.canPlayType('application/vnd.apple.mpegurl')) {\n                // Some browsers (like Safari) support HLS natively.\n                player.src = url;\n                this.support.quality = false;\n            } else {\n                window.console.error('HLS is not supported in this browser.');\n                this.support.quality = false;\n            }\n        } else if (url.indexOf('.mpd') !== -1) {\n            // Handle DASH stream using dash.js.\n            let dashjs = await import('mod_interactivevideo/player/dash');\n            if (typeof dashjs !== 'undefined') {\n                var dashPlayer = dashjs.MediaPlayer().create();\n                dashPlayer.initialize(player, url, false);\n                this.dash = dashPlayer;\n                dashPlayer.on(dashjs.MediaPlayer.events.REPRESENTATION_SWITCH, function() {\n                    const current = dashPlayer.getCurrentRepresentationForType('video');\n                    if (!current) {\n                        return;\n                    }\n                    dispatchEvent('iv:playerQualityChange', {quality: current.absoluteIndex});\n                });\n                dashPlayer.on(dashjs.MediaPlayer.events.ERROR, function() {\n                    dispatchEvent('iv:playerError');\n                });\n                this.support.quality = true;\n            } else {\n                window.console.error('Dash.js library is not loaded.');\n                this.support.quality = false;\n            }\n        } else {\n            // Standard video source.\n            player.src = url;\n            this.support.quality = false;\n        }\n        player.controls = showControls;\n        player.currentTime = start;\n        player.setAttribute('muted', '');\n\n        if (!this.support.quality && document.getElementById('quality')) {\n            // Remove quality button if not supported.\n            document.getElementById('quality').remove();\n        }\n\n        if (document.body.classList.contains('mobiletheme') || autoplay) {\n            // Preload video on mobile app. Must mute to avoid browser restriction.\n            player.setAttribute('autoplay', '');\n        }\n        // Disable keyboard controls.\n        player.tabIndex = -1;\n\n        let self = this;\n        if (!showControls) {\n            document.body.classList.add('no-original-controls');\n        }\n\n        // Play inline.\n        player.setAttribute('playsinline', '');\n\n        // Disable picture-in-picture.\n        player.setAttribute('disablePictureInPicture', '');\n\n        // Disable picture-in-picture.\n        player.setAttribute('disablePictureInPicture', '');\n\n        player.addEventListener('loadedmetadata', function() {\n            self.aspectratio = self.ratio();\n            let totaltime = Number((player.duration).toFixed(2)) - self.frequency;\n            if (player.duration === Infinity || isNaN(player.duration) ||\n                (self.hls && self.hls.latencyController.levelDetails.live)) {\n                totaltime = 0.1;\n                self.live = true;\n            }\n            if (end == 0.1 && !self.live) {\n                end = totaltime;\n            }\n            end = !end ? totaltime : Math.min(end, totaltime);\n            end = Number(end.toFixed(2));\n            self.end = end;\n            self.totaltime = totaltime;\n            self.duration = self.end - self.start;\n            player.pause();\n            dispatchEvent('iv:playerLoaded', {\n                tracks: null\n            });\n            dispatchEvent('iv:playerReady', null, document.getElementById(node));\n        });\n\n        player.addEventListener('pause', function() {\n            self.paused = true;\n            dispatchEvent('iv:playerPaused');\n        });\n\n        player.addEventListener('play', function() {\n            self.paused = false;\n            dispatchEvent('iv:playerPlaying');\n        });\n\n        player.addEventListener('timeupdate', function() {\n            if (self.paused) {\n                return;\n            }\n            if (player.currentTime < self.start) {\n                player.currentTime = self.start;\n            }\n            if (player.currentTime >= self.end + self.frequency && !self.live) {\n                player.currentTime = self.end - self.frequency;\n            }\n            dispatchEvent('iv:playerPlaying');\n            if (self.live) {\n                return;\n            }\n            if (self.ended) {\n                self.ended = false;\n            } else {\n                if (!self.ended && player.currentTime >= self.end) {\n                    self.ended = true;\n                    self.paused = true;\n                    player.pause();\n                    dispatchEvent('iv:playerEnded');\n                }\n            }\n        });\n\n        player.addEventListener('error', function(e) {\n            dispatchEvent('iv:playerError', {error: e});\n        });\n\n        player.addEventListener('ratechange', function() {\n            dispatchEvent('iv:playerRateChange', {rate: player.playbackRate});\n        });\n\n        this.player = player;\n    }\n\n    /**\n     * Visualizes the audio frequency data of the HTML5 video player using a canvas element.\n     * Credit: https://codepen.io/nfj525/pen/rVBaab by Nick Jones\n     * This method creates an audio context and connects it to the video player's audio source.\n     * It then sets up an analyser to get the frequency data and renders a bar graph visualization\n     * on a canvas element with the id \"visualizer\".\n     *\n     * The visualization is updated in real-time using the `requestAnimationFrame` method.\n     *\n     * @method visualizer\n     */\n    visualizer() {\n        var context = new AudioContext();\n        var src = context.createMediaElementSource(this.player);\n        var analyser = context.createAnalyser();\n        var canvas = document.getElementById(\"visualizer\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        var ctx = canvas.getContext(\"2d\");\n        src.connect(analyser);\n        analyser.connect(context.destination);\n\n        analyser.fftSize = 256;\n\n        var bufferLength = analyser.frequencyBinCount;\n        var dataArray = new Uint8Array(bufferLength);\n\n        var WIDTH = canvas.width;\n        var HEIGHT = canvas.height;\n\n        var barWidth = (WIDTH / bufferLength) * 2.5;\n        var barHeight;\n        var x = 0;\n\n        const renderFrame = () => {\n            requestAnimationFrame(renderFrame);\n            x = 0;\n            analyser.getByteFrequencyData(dataArray);\n            ctx.fillStyle = \"#000\";\n            ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n            for (var i = 0; i < bufferLength; i++) {\n                barHeight = dataArray[i];\n                var r = barHeight + (25 * (i / bufferLength));\n                var g = 250 * (i / bufferLength);\n                var b = 50;\n\n                ctx.fillStyle = \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\n                ctx.fillRect(x, HEIGHT - barHeight, barWidth, barHeight);\n\n                x += barWidth + 1;\n            }\n        };\n        renderFrame();\n    }\n\n    /**\n     * Plays the HTML5 video using the player instance.\n     *\n     * @method play\n     */\n    play() {\n        if (this.live) {\n            // Seek to the end of the video to simulate live streaming.\n            if (this.dash) {\n                this.dash.seekToOriginalLive();\n            }\n            if (this.hls) {\n                let seektime = this.hls.liveSyncPosition;\n                this.seek(seektime);\n            }\n        }\n        this.player.play();\n        this.paused = false;\n    }\n    /**\n     * Pauses the video playback.\n     *\n     * This method calls the pause function on the player instance to stop the video.\n     */\n    pause() {\n        this.player.pause();\n        this.paused = true;\n        return true;\n    }\n    /**\n     * Stops the video playback and sets the current time to the specified start time.\n     *\n     * @param {number} starttime - The time (in seconds) to set the video's current time to.\n     */\n    stop(starttime) {\n        this.player.pause();\n        this.player.currentTime = starttime;\n    }\n    /**\n     * Seeks the video to a specified time.\n     *\n     * @param {number} time - The time in seconds to seek to.\n     * @returns {boolean} Returns true when the seek operation is initiated.\n     */\n    seek(time) {\n        this.ended = false;\n        this.player.currentTime = time;\n        dispatchEvent('iv:playerSeek', {time});\n        return true;\n    }\n    /**\n     * Retrieves the current playback time of the video.\n     *\n     * @returns {number} The current time of the video in seconds.\n     */\n    getCurrentTime() {\n        return this.player.currentTime;\n    }\n    /**\n     * Retrieves the duration of the video.\n     *\n     * @returns {number} The duration of the video in seconds.\n     */\n    getDuration() {\n        return this.player.duration;\n    }\n    /**\n     * Checks if the video player is currently paused.\n     *\n     * @returns {boolean} True if the player is paused, false otherwise.\n     */\n    isPaused() {\n        if (this.paused) {\n            return true;\n        }\n        return this.player.paused;\n    }\n    /**\n     * Checks if the video player is currently playing.\n     *\n     * @returns {boolean} True if the video is playing, false if it is paused.\n     */\n    isPlaying() {\n        if (this.paused) {\n            return false;\n        }\n        return !this.player.paused;\n    }\n\n    /**\n     * Checks if the video has ended.\n     *\n     * @returns {boolean} True if the video has ended, otherwise false.\n     */\n    isEnded() {\n        return this.player.ended || this.player.currentTime >= this.end;\n    }\n    /**\n     * Calculates the aspect ratio of the video.\n     * If the video is wider than a 16:9 ratio, it returns the actual video ratio.\n     * Otherwise, it returns the 16:9 ratio.\n     *\n     * @returns {number} The aspect ratio of the video.\n     */\n    ratio() {\n        if (this.audio || !this.player.videoWidth || !this.player.videoHeight) {\n            return 16 / 9;\n        }\n        return this.player.videoWidth / this.player.videoHeight;\n    }\n    /**\n     * Destroys the HTML5 video player instance.\n     *\n     * This method pauses the video, removes the source attribute, and reloads the player.\n     * It is used to clean up the player instance and release any resources it may be holding.\n     */\n    destroy() {\n        document.getElementById('video-wrapper').innerHTML = '<div id=\"player\" style=\"width:100%; max-width: 100%\"></div>';\n        this.player.pause();\n        this.player.removeAttribute('src');\n        this.player.load();\n        if (this.hls) {\n            this.hls.destroy();\n        }\n        if (this.dash) {\n            this.dash.destroy();\n        }\n    }\n    /**\n     * Retrieves the current state of the video player.\n     *\n     * @returns {string} - Returns 'paused' if the player is paused, otherwise 'playing'.\n     */\n    getState() {\n        return this.player.paused ? 'paused' : 'playing';\n    }\n\n    /**\n     * Sets the playback rate of the video player.\n     *\n     * @param {number} rate - The desired playback rate. A value of 1.0 represents normal speed.\n     */\n    setRate(rate) {\n        this.player.playbackRate = rate;\n    }\n\n    /**\n     * Mutes the HTML5 video player.\n     */\n    mute() {\n        this.player.muted = true;\n    }\n    /**\n     * Unmutes the video player.\n     */\n    unMute() {\n        this.player.muted = false;\n        this.player.volume = 1;\n    }\n\n    /**\n     * Returns the original video player instance.\n     *\n     * @returns {Object} The video player instance.\n     */\n    originalPlayer() {\n        return this.player;\n    }\n\n    /**\n     * Sets the video quality.\n     *\n     * Note: This functionality is not supported.\n     *\n     * @param {string} quality - The desired quality setting.\n     * @returns {string} The quality setting that was passed in.\n     */\n    setQuality(quality) {\n        if (this.support.quality) {\n            // Implement quality change here.\n            if (this.hls) {\n                this.hls.currentLevel = quality;\n            } else if (this.dash) {\n                if (quality === -1) {\n                    // Enable automatic quality switching.\n                    this.dash.updateSettings({\n                        streaming: {\n                            abr: {\n                                autoSwitchBitrate: {\n                                    video: true\n                                }\n                            }\n                        }\n                    });\n                } else {\n                    // Disable automatic quality switching and set manual quality.\n                    this.dash.updateSettings({\n                        streaming: {\n                            abr: {\n                                autoSwitchBitrate: {\n                                    video: false\n                                }\n                            }\n                        }\n                    });\n                    this.dash.setRepresentationForTypeByIndex('video', quality);\n                }\n            }\n        }\n        return quality;\n    }\n\n    getQualities() {\n        if (this.support.quality) {\n            // Prepend an \"Auto\" option for quality selection.\n            let keys, values, current;\n            if (this.hls) {\n                keys = [-1, ...this.hls.levels.map((level, index) => index)];\n                values = ['Auto', ...this.hls.levels.map((level) => level.height + 'p')];\n                current = this.hls.currentLevel;\n            } else if (this.dash) {\n                const qualities = this.dash.getRepresentationsByType('video');\n                keys = [-1, ...qualities.map((quality) => quality.absoluteIndex)];\n                values = ['Auto', ...qualities.map((quality) => quality.height\n                    + 'p (' + Math.round(quality.bitrateInKbit) + 'kbps)')];\n                current = this.dash.getCurrentRepresentationForType('video').absoluteIndex;\n                if (!current) {\n                    current = -1;\n                }\n            }\n\n            return {\n                qualities: keys,\n                qualitiesLabel: values,\n                currentQuality: current,\n            };\n        }\n        return [];\n    }\n}\n\nexport default Html5Video;"],"names":["constructor","type","frequency","useAnimationFrame","support","playbackrate","quality","url","start","end","opts","showControls","node","autoplay","allowAutoplay","document","getElementById","this","requireVideoBlock","player","posterImage","poster","ext","split","pop","indexOf","audio","canvas","insertAdjacentHTML","style","visibility","Hls","isSupported","hls","on","Events","MANIFEST_PARSED","event","data","hlsdata","loadSource","attachMedia","LEVEL_SWITCHED","level","ERROR","fatal","error","canPlayType","src","window","console","dashjs","dashPlayer","MediaPlayer","create","initialize","dash","events","REPRESENTATION_SWITCH","current","getCurrentRepresentationForType","absoluteIndex","controls","currentTime","setAttribute","remove","body","classList","contains","tabIndex","self","add","addEventListener","aspectratio","ratio","totaltime","Number","duration","toFixed","Infinity","isNaN","latencyController","levelDetails","live","Math","min","pause","tracks","paused","ended","e","rate","playbackRate","visualizer","context","AudioContext","createMediaElementSource","analyser","createAnalyser","width","innerWidth","height","innerHeight","ctx","getContext","connect","destination","fftSize","barHeight","bufferLength","frequencyBinCount","dataArray","Uint8Array","WIDTH","HEIGHT","barWidth","x","renderFrame","requestAnimationFrame","getByteFrequencyData","fillStyle","fillRect","i","r","g","play","seekToOriginalLive","seektime","liveSyncPosition","seek","stop","starttime","time","getCurrentTime","getDuration","isPaused","isPlaying","isEnded","videoWidth","videoHeight","destroy","innerHTML","removeAttribute","load","getState","setRate","mute","muted","unMute","volume","originalPlayer","setQuality","currentLevel","updateSettings","streaming","abr","autoSwitchBitrate","video","setRepresentationForTypeByIndex","getQualities","keys","values","levels","map","index","qualities","getRepresentationsByType","round","bitrateInKbit","qualitiesLabel","currentQuality"],"mappings":"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"}