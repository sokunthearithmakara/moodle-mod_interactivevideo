{"version":3,"file":"rutube.min.js","sources":["../../src/player/rutube.js"],"sourcesContent":["/* eslint-disable */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Rutube Player class\n *\n * @module     mod_interactivevideo/player/rutube\n * @copyright  2024 Sokunthearith Makara <sokunthearithmakara@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {dispatchEvent} from 'core/event_dispatcher';\nimport $ from 'jquery';\nimport allowAutoplay from 'mod_interactivevideo/player/checkautoplay';\n\nlet player = {};\n\nclass Rutube {\n    /**\n     * Constructs a Rutube player instance.\n     */\n    constructor() {\n        this.type = 'rutube';\n        this.useAnimationFrame = true;\n        this.frequency = 0.25;\n        this.support = {\n            playbackrate: false,\n            quality: true,\n            password: false,\n        };\n    }\n    async getInfo(url, node) {\n        this.node = node;\n        let self = this;\n        let regex = /(?:https?:\\/\\/)?(?:www\\.)?(?:rutube\\.ru\\/video\\/(?:private\\/)?)(.+)/;\n        let match = regex.exec(url);\n        let videoId = match[1];\n        // Get the value of the private key url parameter.\n        let privateKey = '';\n        let keys = url.split('/?p=');\n        if (keys.length > 1) {\n            privateKey = keys[1];\n            privateKey = privateKey.split('&')[0];\n        }\n        videoId = videoId.split(\"?\")[0];\n        return new Promise((resolve) => {\n            $.ajax({\n                url: M.cfg.wwwroot + '/mod/interactivevideo/ajax.php',\n                type: 'POST',\n                data: {\n                    action: 'get_from_url',\n                    contextid: M.cfg.contextid,\n                    url: `https://rutube.ru/api/play/options/${videoId}${privateKey != '' ? `?p=${privateKey}` : ''}`,\n                    sesskey: M.cfg.sesskey,\n                },\n            }).done(function(data) {\n                if (data.html === undefined) {\n                    dispatchEvent('iv:playerError', {error: data});\n                }\n                self.posterImage = data.thumbnail_url;\n                self.totaltime = data.duration / 1000;\n                self.title = data.title;\n                let iframeurl = `https://rutube.ru/play/embed/${videoId}${privateKey != '' ? `?p=${privateKey}` : ''}`;\n                $(`#${node}`).replaceWith(`<iframe id=\"${node}\" src=\"${iframeurl}\" frameBorder=\"0\" allow=\"clipboard-write; autoplay\"\n                 webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`);\n\n                player[node] = document.getElementById(node);\n                self.player = player[node];\n                window.addEventListener('message', function(event) {\n                    var message = '';\n                    try {\n                        message = JSON.parse(event.data);\n                    } catch (e) {\n                        return;\n                    }\n                    switch (message.type) {\n                        case 'player:ready':\n                            resolve({\n                                duration: self.totaltime,\n                                title: self.title,\n                                posterImage: self.posterImage,\n                            });\n                            break;\n                        case 'player:currentTime':\n                            self.currentTime = message.data.time;\n                            break;\n                    };\n                });\n            });\n        });\n    }\n    /**\n     * Load a Rutube player instance.\n     * Documented at https://rutube.ru/info/embed\n     *\n     * @param {string} url - The URL of the Rutube video.\n     * @param {number} start - The start time of the video in seconds.\n     * @param {number} end - The end time of the video in seconds.\n     * @param {object} opts - The options for the player.\n     */\n    async load(url, start, end, opts = {}) {\n        this.showControls = opts.showControls || false;\n        const node = opts.node || 'player';\n        this.node = node;\n        this.allowAutoplay = await allowAutoplay(document.getElementById(node));\n        if (!this.allowAutoplay) {\n            dispatchEvent('iv:autoplayBlocked');\n        }\n        this.start = start;\n        this.aspectratio = 16 / 9;\n        // Sample video: https://rutube.ru/video/9235cf652dcb9d29fb02f3f6692d2a47\n        // Private video: https://rutube.ru/video/private/9235cf652dcb9d29fb02f3f6692d2a47/?p=sdf234234234\n        const regex = /https:\\/\\/rutube\\.ru\\/video\\/(?:private\\/)?(.+)/;\n        let match = regex.exec(url);\n        let videoId = match[1];\n        // Get the value of the private key url parameter.\n        let privateKey = '';\n        let keys = url.split('/?p=');\n        if (keys.length > 1) {\n            privateKey = keys[1];\n            privateKey = privateKey.split('&')[0];\n        }\n        videoId = videoId.split(\"?\")[0];\n        this.videoId = videoId;\n        let self = this;\n        $.ajax({\n            url: M.cfg.wwwroot + '/mod/interactivevideo/ajax.php',\n            type: 'POST',\n            data: {\n                action: 'get_from_url',\n                contextid: M.cfg.contextid,\n                url: `https://rutube.ru/api/play/options/${videoId}${privateKey != '' ? `?p=${privateKey}` : ''}`,\n                sesskey: M.cfg.sesskey,\n            },\n        }).done(function(data) {\n            if (data.html === undefined) {\n                dispatchEvent('iv:playerError', {error: data});\n            }\n            self.posterImage = data.thumbnail_url;\n            let totaltime = data.duration / 1000 - self.frequency;\n            end = !end ? totaltime : Math.min(end, totaltime);\n            end = Number(end.toFixed(2));\n            self.end = end;\n            self.totaltime = Number(totaltime.toFixed(2));\n            self.duration = self.end - self.start;\n            self.currentTime = self.start;\n            let html = $(data.html);\n            self.aspectratio = html.attr('width') / html.attr('height');\n            self.title = data.title;\n            let iframeurl = `https://rutube.ru/play/embed/${videoId}${privateKey != '' ? `?p=${privateKey}` : ''}`;\n            $(`#${node}`).replaceWith(`<iframe id=\"player\" src=\"${iframeurl}\" frameBorder=\"0\" allow=\"clipboard-write; autoplay\"\n                 webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`);\n\n            player[node] = document.getElementById('player');\n            self.player = player[node];\n            self.currentQuality = 'auto';\n            window.addEventListener('message', function(event) {\n                var message = '';\n                try {\n                    message = JSON.parse(event.data);\n                } catch (e) {\n                    return;\n                }\n                switch (message.type) {\n                    case 'player:qualityList':\n                        self.qualities = message.data.list;\n                        break;\n                    case 'player:currentQuality':\n                        self.currentQuality = message.data.quality.isAutoQuality ? 'auto' : message.data.quality.quality;\n                        break;\n                    case 'player:changeState':\n                        if (message.data.state === 'playing') {\n                            let currentTime = self.currentTime;\n                            dispatchEvent('iv:playerPlay');\n                            if (currentTime < self.start) {\n                                self.seek(self.start);\n                                self.ended = false;\n                                self.paused = false;\n                                dispatchEvent('iv:playerPlaying');\n                                return;\n                            }\n                            if (!self.ended && currentTime >= self.end) {\n                                self.ended = true;\n                                self.paused = true;\n                                dispatchEvent('iv:playerEnded');\n                                return;\n                            }\n                            self.paused = false;\n                            self.ended = false;\n                            dispatchEvent('iv:playerPlaying');\n                        } else if (message.data.state === 'paused' || message.data.state === 'pause') {\n                            self.paused = true;\n                            dispatchEvent('iv:playerPaused');\n                        } else if (message.data.state === 'ended' || message.data.state === 'stopped') {\n                            self.ended = true;\n                            self.paused = true;\n                            dispatchEvent('iv:playerEnded');\n                        }\n                        break;\n                    case 'player:ready':\n                        dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                        break;\n                    case 'player:currentTime':\n                        self.currentTime = message.data.time;\n                        if (self.currentTime < self.start) {\n                            self.currentTime = self.start;\n                            self.seek(self.start);\n                        }\n                        if (self.currentTime > self.end + self.frequency) {\n                            self.seek(self.end - self.frequency);\n                        }\n                        if (self.state === 'paused') {\n                            dispatchEvent('iv:playerSeek', {time: self.currentTime});\n                        }\n                        break;\n                    case 'player:rollState':\n                        if (message.data.state === 'play') { // Ad started\n                            $(\".video-block, #video-block\").addClass('d-none');\n                            $(\"#start-screen\").addClass('bg-transparent d-none');\n                            $('#annotation-canvas').removeClass('d-none w-0');\n                        } else if (message.data.state === 'complete') { // Ad complete/error\n                            $(\".video-block, #video-block\").removeClass('d-none');\n                            $(\"#start-screen\").removeClass('bg-transparent d-none');\n                        }\n                        break;\n                    case 'player:error':\n                        dispatchEvent('iv:playerError', {error: message.data});\n                        break;\n                };\n            });\n        }).catch(function(error) {\n            dispatchEvent('iv:playerError', {error: error});\n        });\n    }\n    doCommand(commandJSON) {\n        if (!player[this.node]) {\n            return null;\n        }\n        return player[this.node].contentWindow.postMessage(JSON.stringify(commandJSON), '*');\n    }\n    /**\n     * Plays the video using the Rutube player instance.\n     *\n     */\n    play() {\n        this.doCommand({type: 'player:play', data: {}});\n        if (!this.showControls && !this.controlHidden) {\n            this.doCommand({type: 'player:hideControls', data: {}});\n            this.controlHidden = true;\n        }\n        this.paused = false;\n    }\n    /**\n     * Pauses the Rutube player.\n     *\n     * This method calls the `pause` function on the `player` object to pause the video playback.\n     */\n    async pause() {\n        await this.doCommand({type: 'player:pause', data: {}});\n        this.paused = true;\n        return true;\n    }\n    /**\n     * Stops the video playback and sets the current time to the specified start time.\n     *\n     * @param {number} starttime - The time in seconds to which the video should be set before pausing.\n     */\n    stop(starttime) {\n        this.doCommand({type: 'player:stop', data: {}});\n    }\n    /**\n     * Seeks the video to a specified time.\n     *\n     * @param {number} time - The time in seconds to seek to.\n     * @returns {Promise<number>} A promise that resolves to the time in seconds to which the video was seeked.\n     */\n    seek(time) {\n        if (!time || isNaN(time)) {\n            return;\n        }\n        if (time < 0) {\n            time = 0;\n        }\n        this.ended = false;\n        this.doCommand({type: 'player:setCurrentTime', data: {time}});\n        dispatchEvent('iv:playerSeek', {time: time});\n        return time;\n    }\n    /**\n     * Retrieves the current playback time of the video.\n     *\n     * @returns {Promise<number>} A promise that resolves to the current time in seconds.\n     */\n    getCurrentTime() {\n        if (!player[this.node]) {\n            return 0;\n        }\n        return this.currentTime;\n    }\n    /**\n     * Asynchronously retrieves the duration of the video.\n     *\n     * @returns {Promise<number>} A promise that resolves to the duration of the video in seconds.\n     */\n    getDuration() {\n        if (!player[this.node]) {\n            return 0;\n        }\n        let duration = this.totaltime;\n        return duration;\n    }\n    /**\n     * Checks if the Rutube player is paused.\n     *\n     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the player is paused.\n     */\n    isPaused() {\n        if (!player[this.node]) {\n            return true;\n        }\n        return this.paused;\n    }\n    /**\n     * Checks if the Rutube player is currently playing.\n     *\n     * @returns {Promise<boolean>} A promise that resolves to `true` if the player is playing, otherwise `false`.\n     */\n    isPlaying() {\n        if (!player[this.node]) {\n            return false;\n        }\n        return !this.paused;\n    }\n    /**\n     * Checks if the Rutube player has ended.\n     *\n     * @function isEnded\n     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the player has ended.\n     */\n    isEnded() {\n        if (!player[this.node]) {\n            return false;\n        }\n        return this.ended || this.currentTime >= this.end;\n    }\n    /**\n     * Calculates the aspect ratio of the video.\n     * If the video's aspect ratio is greater than 16:9, it returns the actual aspect ratio.\n     * Otherwise, it returns the 16:9 aspect ratio.\n     *\n     * @returns {Promise<number>} The aspect ratio of the video.\n     */\n    ratio() {\n        if (!player[this.node]) {\n            return 16 / 9;\n        }\n        return this.aspectratio;\n    }\n    /**\n     * Destroys the Rutube player instance if it is initialized.\n     * If the player is not initialized, logs an error message to the console.\n     */\n    destroy() {\n        $(this.player).remove();\n        player[this.node] = null;\n        dispatchEvent('iv:playerDestroyed');\n    }\n    /**\n     * Asynchronously retrieves the current state of the video player.\n     *\n     * @returns {Promise<string>} A promise that resolves to a string indicating the player's state, either 'paused' or 'playing'.\n     */\n    async getState() {\n        if (!player[this.node]) {\n            return 'paused';\n        }\n        const paused = await player[this.node].isPaused();\n        return paused ? 'paused' : 'playing';\n    }\n    /**\n     * Sets the playback rate for the Rutube player.\n     *\n     * @param {number} rate - The desired playback rate.\n     *                        This should be a value supported by the Rutube player.\n     */\n    setRate(rate) {\n        if (!player[this.node]) {\n            return;\n        }\n        player[this.node].setPlaybackRate(rate);\n    }\n    /**\n     * Mutes the Rutube player by setting the volume to 0.\n     */\n    mute() {\n        this.doCommand({type: 'player:mute', data: {}});\n        this.muted = true;\n        dispatchEvent('iv:playerVolumeChange', {volume: 0});\n    }\n    /**\n     * Unmutes the Rutube player by setting the volume to 1.\n     */\n    unMute() {\n        this.doCommand({type: 'player:unMute', data: {}});\n        this.doCommand({type: 'player:setVolume', data: {volume: 1}});\n        this.muted = false;\n        dispatchEvent('iv:playerVolumeChange', {volume: 1});\n    }\n\n    isMuted() {\n        if (!player[this.node]) {\n            return false;\n        }\n        return this.muted;\n    }\n\n    /**\n     * Set quality of the video (NOT IMPLEMENTED)\n     * @param {String} quality\n     */\n    async setQuality(quality) {\n        return this.doCommand({type: 'player:changeQuality', data: {quality}});\n    }\n    /**\n     * Get the available qualities of the video (NOT IMPLEMENTED)\n     */\n    async getQualities() {\n        if (!player[this.node]) {\n            return null;\n            }\n        return {\n            qualities: ['auto', ...this.qualities],\n            qualitiesLabel: [M.util.get_string('auto', 'mod_interactivevideo'), ...this.qualities],\n            currentQuality: this.currentQuality,\n        };\n    }\n\n    /**\n     * Set subtitle of the video (NOT IMPLEMENTED)\n     *  @param {String} language\n     */\n    async setCaption(language) {\n        return false;\n    }\n\n    /**\n     * Returns the original Rutube player instance.\n     *\n     * @returns {Object} The Rutube player instance.\n     */\n    originalPlayer() {\n        return player[this.node];\n    }\n}\n\nexport default Rutube;"],"names":["player","constructor","type","useAnimationFrame","frequency","support","playbackrate","quality","password","url","node","self","this","videoId","exec","privateKey","keys","split","length","Promise","resolve","ajax","M","cfg","wwwroot","data","action","contextid","sesskey","done","undefined","html","error","posterImage","thumbnail_url","totaltime","duration","title","iframeurl","replaceWith","document","getElementById","window","addEventListener","event","message","JSON","parse","e","currentTime","time","start","end","opts","showControls","allowAutoplay","aspectratio","Math","min","Number","toFixed","attr","currentQuality","qualities","list","isAutoQuality","state","seek","ended","paused","addClass","removeClass","catch","doCommand","commandJSON","contentWindow","postMessage","stringify","play","controlHidden","stop","starttime","isNaN","getCurrentTime","getDuration","isPaused","isPlaying","isEnded","ratio","destroy","remove","setRate","rate","setPlaybackRate","mute","muted","volume","unMute","isMuted","qualitiesLabel","util","get_string","language","originalPlayer"],"mappings":"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"}