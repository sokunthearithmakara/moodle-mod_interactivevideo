{"version":3,"file":"kinescope.min.js","sources":["../../src/player/kinescope.js"],"sourcesContent":["/* eslint-disable */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Kinescope Player class\n *\n * @module     mod_interactivevideo/player/kinescope\n * @copyright  2024 Sokunthearith Makara <sokunthearithmakara@gmail.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {dispatchEvent} from 'core/event_dispatcher';\nimport $ from 'jquery';\nimport allowAutoplay from 'mod_interactivevideo/player/checkautoplay';\n\nlet player;\n\nclass Kinescope {\n    /**\n     * Constructor for the Kinescope player.\n     */\n    constructor() {\n        this.type = 'kinescope';\n        this.useAnimationFrame = false;\n        this.support = {\n            playbackrate: true,\n            quality: true,\n            password: true,\n        };\n        this.frequency = 0.3;\n    }\n    /**\n     * Load a Sprout Video player instance.\n     * Documented at https://kinescope.notion.site/Kinescope-Player-Docs-4e1ecb05be98469da3367ddb71edd9d8\n     *\n     * @param {string} url - The URL of the Sprout Video video.\n     * @param {number} start - The start time of the video in seconds.\n     * @param {number} end - The end time of the video in seconds.\n     * @param {object} opts - The options for the player.\n     */\n    async load(url, start, end, opts = {}) {\n        const showControls = opts.showControls || false;\n        const node = opts.node || 'player';\n        this.node = node;\n        this.start = start;\n        this.allowAutoplay = await allowAutoplay(document.getElementById(node));\n        if (!this.allowAutoplay) {\n            dispatchEvent('iv:autoplayBlocked');\n        }\n        // Sample video: https://kinescope.io/{token}\n        let regex = /kinescope\\.io\\/(.*)/;\n        let match = regex.exec(url);\n        let videoId = match[1];\n        this.videoId = videoId;\n        let ready = false;\n        let self = this;\n        self.aspectratio = 16 / 9;\n        const playerEvents = function(playerFactory) {\n            playerFactory\n                .create('player', {\n                    url: 'https://kinescope.io/' + videoId,\n                    behaviour: {\n                        playsInline: true,\n                        keyboard: false,\n                        localStorage: false,\n                        preload: true,\n                    },\n                    ui: {\n                        controls: showControls,\n                    }\n                })\n                .then(function(pl) {\n                    pl.on(pl.Events.Ready, async function(event) {\n                        player = event.target;\n                        let totaltime = Number(event.data.duration.toFixed(2)) - self.frequency;\n                        end = !end ? totaltime : Math.min(end, totaltime);\n                        end = Number(end.toFixed(2));\n                        self.aspectratio = event.data.aspectRatio.ratio;\n                        self.end = end;\n                        self.totaltime = Number(totaltime.toFixed(2));\n                        self.duration = self.end - self.start;\n                        self.texttracks = event.data.textTracks;\n                        self.qualities = event.data.qualities;\n                        // Handle text tracks.\n                        player.disableTextTrack();\n                        let tracks = [];\n                        if (self.texttracks.length > 0) {\n                            self.texttracks.forEach((track) => {\n                                tracks.push({\n                                    label: track.label,\n                                    code: track.language,\n                                });\n                            });\n                            self.captions = tracks;\n                        }\n\n                        dispatchEvent('iv:playerLoaded', {\n                            tracks: tracks,\n                            qualities: self.getQualities(),\n                        });\n\n                        // Scrap the video url to get the video title and poster image in the head.\n                        if (opts.editform) {\n                            const response = await fetch('https://kinescope.io/embed/' + videoId);\n                            const data = await response.text();\n                            let parser = new DOMParser();\n                            let doc = parser.parseFromString(data, 'text/html');\n                            let page = $(doc);\n                            let title = page.find('meta[property=\"og:title\"]').attr('content');\n                            let poster = page.find('meta[property=\"og:image\"]').attr('content');\n                            self.title = title;\n                            self.posterImage = poster;\n                        }\n                        await player.seekTo(start);\n                        await player.pause();\n                        ready = true;\n                        dispatchEvent('iv:playerReady', null, document.getElementById(node));\n                    });\n                    pl.on(pl.Events.Play, async function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        self.paused = false;\n                        self.ended = false;\n                        dispatchEvent('iv:playerPlaying');\n                        const time = await player.getCurrentTime();\n                        if (time >= end) {\n                            self.ended = true;\n                            self.paused = true;\n                            dispatchEvent('iv:playerEnded');\n                        }\n                    });\n                    pl.on(pl.Events.Pause, async function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        self.paused = true;\n                        dispatchEvent('iv:playerPaused');\n                    });\n                    pl.on(pl.Events.Ended, function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        self.ended = true;\n                        self.paused = true;\n                        dispatchEvent('iv:playerEnded');\n                    });\n                    pl.on(pl.Events.TimeUpdate, async function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        let currentTime = await player.getCurrentTime();\n                        if (currentTime < start) {\n                            await player.seekTo(start);\n                            self.ended = false;\n                        }\n                        if (currentTime > end + self.frequency) {\n                            await player.seekTo(end - self.frequency);\n                            return;\n                        }\n                        if (currentTime >= end) {\n                            self.ended = true;\n                            await player.seekTo(end);\n                            dispatchEvent('iv:playerEnded');\n                        } else if (!self.paused) {\n                            self.paused = false;\n                            dispatchEvent('iv:playerPlaying');\n                        };\n                    });\n                    pl.on(pl.Events.QualityChanged, async function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        dispatchEvent('iv:playerQualityChange', {quality: event.quality});\n                    })\n                    pl.on(pl.Events.PlaybackRateChange, async function(event) {\n                        if (!ready) {\n                            return;\n                        }\n                        dispatchEvent('iv:playerSpeedChange', {rate: event.playbackRate});\n                    });\n                });\n        };\n\n        // Create a player instance.\n        if (!window.Kinescope) {\n            var tag = document.createElement('script');\n            tag.src = 'https://player.kinescope.io/latest/iframe.player.js';\n            tag.async = true;\n            tag.as = \"script\";\n            tag.rel = \"preload\";\n            var firstScriptTag = document.getElementsByTagName('script')[0];\n            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n            window.onKinescopeIframeAPIReady = async function(playerFactory) {\n                window.playerFactory = playerFactory;\n                playerEvents(playerFactory);\n            };\n        } else {\n            // Create an iframe.\n            $('#video-wrapper').html('<iframe id=\"player\"></iframe>');\n            playerEvents(window.playerFactory);\n        }\n    }\n    /**\n     * Plays the video using the Sprout Video player instance.\n     * If the player is not initialized, logs an error to the console.\n     */\n    async play() {\n        await player.play();\n        this.paused = false;\n    }\n    /**\n     * Pauses the Sprout Video player.\n     *\n     * This method calls the `pause` function on the `player` object to pause the video playback.\n     */\n    async pause() {\n        await player.pause();\n        this.paused = true;\n    }\n    /**\n     * Stops the video playback and sets the current time to the specified start time.\n     *\n     * @param {number} starttime - The time in seconds to which the video should be set before pausing.\n     */\n    stop(starttime) {\n        player.seekTo(starttime);\n        player.pause();\n    }\n    /**\n     * Seeks the video to a specified time.\n     *\n     * @param {number} time - The time in seconds to seek to.\n     * @returns {Promise<number>} A promise that resolves to the time in seconds to which the video was seeked.\n     */\n    seek(time) {\n        if (time < 0) {\n            time = 0;\n        }\n        this.ended = false;\n        player.seekTo(parseFloat(time));\n        dispatchEvent('iv:playerSeek', {time: time});\n        return time;\n    }\n    /**\n     * Retrieves the current playback time of the video.\n     *\n     * @returns {Promise<number>} A promise that resolves to the current time in seconds.\n     */\n    async getCurrentTime() {\n        return await player.getCurrentTime();\n    }\n    /**\n     * Asynchronously retrieves the duration of the video.\n     *\n     * @returns {Promise<number>} A promise that resolves to the duration of the video in seconds.\n     */\n    async getDuration() {\n        const duration = await player.getDuration();\n        return duration;\n    }\n    /**\n     * Checks if the Sprout Video player is paused.\n     *\n     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the player is paused.\n     */\n    async isPaused() {\n        if (this.paused) {\n            return true;\n        }\n        let paused = await player.isPaused();\n        return paused;\n    }\n    /**\n     * Checks if the Sprout Video player is currently playing.\n     *\n     * @returns {Promise<boolean>} A promise that resolves to `true` if the player is playing, otherwise `false`.\n     */\n    async isPlaying() {\n        if (this.paused) {\n            return false;\n        }\n        let paused = await player.isPaused();\n        return !paused;\n    }\n    /**\n     * Checks if the Sprout Video player has ended.\n     *\n     * @async\n     * @function isEnded\n     * @returns {Promise<boolean>} A promise that resolves to a boolean indicating whether the player has ended.\n     */\n    async isEnded() {\n        if (this.ended) {\n            return true;\n        }\n        let ended = await player.isEnded();\n        return ended;\n    }\n    /**\n     * Calculates the aspect ratio of the video.\n     * If the video's aspect ratio is greater than 16:9, it returns the actual aspect ratio.\n     * Otherwise, it returns the 16:9 aspect ratio.\n     *\n     * @returns {Promise<number>} The aspect ratio of the video.\n     */\n    async ratio() {\n        return this.aspectratio;\n    }\n    /**\n     * Destroys the Sprout Video player instance if it is initialized.\n     * If the player is not initialized, logs an error message to the console.\n     */\n    async destroy() {\n        if (player) {\n            player.off();\n            await player.destroy();\n        } else {\n            $(`#${this.node}`).remove();\n        }\n    }\n    /**\n     * Asynchronously retrieves the current state of the video player.\n     *\n     * @returns {Promise<string>} A promise that resolves to a string indicating the player's state, either 'paused' or 'playing'.\n     */\n    async getState() {\n        const paused = await player.isPaused();\n        return paused ? 'paused' : 'playing';\n    }\n    /**\n     * Sets the playback rate for the Sprout Video player.\n     *\n     * @param {number} rate - The desired playback rate.\n     *                        This should be a value supported by the Sprout Video player.\n     */\n    setRate(rate) {\n        player.setPlaybackRate(rate);\n    }\n    /**\n     * Mutes the Sprout Video player by setting the volume to 0.\n     */\n    mute() {\n        player.mute();\n    }\n    /**\n     * Unmutes the Sprout Video player by setting the volume to 1.\n     */\n    unMute() {\n        player.unmute();\n        player.setVolume(1);\n    }\n\n    /**\n     * Set quality of the video\n     * @param {String} quality\n     */\n    async setQuality(quality) {\n        await player.setVideoQuality(quality);\n        return quality;\n    }\n    /**\n     * Get the available qualities of the video\n     */\n    async getQualities() {\n        let qualities = await player.getVideoQualityList();\n        let keys = qualities;\n        let values = qualities.map(x => x == 'auto' ? 'Auto' : x);\n        let current = await player.getCurrentVideoQuality();\n        return {\n            qualities: keys,\n            qualitiesLabel: values,\n            currentQuality: current,\n        };\n    }\n\n    /**\n     * Set subtitle\n     *  @param {String} language\n     */\n    async setCaption(language) {\n        if (language === 'off') {\n            await player.disableTextTrack();\n        } else {\n            await player.enableTextTrack(language);\n        }\n        return language;\n    }\n\n    /**\n     * Returns the original Sprout Video player instance.\n     *\n     * @returns {Object} The Sprout Video player instance.\n     */\n    originalPlayer() {\n        return player;\n    }\n}\n\nexport default Kinescope;"],"names":["player","constructor","type","useAnimationFrame","support","playbackrate","quality","password","frequency","url","start","end","opts","showControls","node","allowAutoplay","document","getElementById","this","videoId","exec","ready","self","aspectratio","playerEvents","playerFactory","create","behaviour","playsInline","keyboard","localStorage","preload","ui","controls","then","pl","on","Events","Ready","async","event","target","totaltime","Number","data","duration","toFixed","Math","min","aspectRatio","ratio","texttracks","textTracks","qualities","disableTextTrack","tracks","length","forEach","track","push","label","code","language","captions","getQualities","editform","response","fetch","text","doc","DOMParser","parseFromString","page","title","find","attr","poster","posterImage","seekTo","pause","Play","paused","ended","getCurrentTime","Pause","Ended","TimeUpdate","currentTime","QualityChanged","PlaybackRateChange","rate","playbackRate","window","Kinescope","html","tag","createElement","src","as","rel","firstScriptTag","getElementsByTagName","parentNode","insertBefore","onKinescopeIframeAPIReady","play","stop","starttime","seek","time","parseFloat","getDuration","isPaused","isEnded","off","destroy","remove","setRate","setPlaybackRate","mute","unMute","unmute","setVolume","setVideoQuality","getVideoQualityList","qualitiesLabel","map","x","currentQuality","getCurrentVideoQuality","enableTextTrack","originalPlayer"],"mappings":";;;;;;;SA2BIA,wMAMAC,mBACSC,KAAO,iBACPC,mBAAoB,OACpBC,QAAU,CACXC,cAAc,EACdC,SAAS,EACTC,UAAU,QAETC,UAAY,cAWVC,IAAKC,MAAOC,SAAKC,4DAAO,SACzBC,aAAeD,KAAKC,eAAgB,EACpCC,KAAOF,KAAKE,MAAQ,cACrBA,KAAOA,UACPJ,MAAQA,WACRK,oBAAsB,0BAAcC,SAASC,eAAeH,OAC5DI,KAAKH,mDACQ,0BAKdI,QAFQ,sBACMC,KAAKX,KACH,QACfU,QAAUA,YACXE,OAAQ,EACRC,KAAOJ,KACXI,KAAKC,YAAc,GAAK,QAClBC,aAAe,SAASC,eAC1BA,cACKC,OAAO,SAAU,CACdjB,IAAK,wBAA0BU,QAC/BQ,UAAW,CACPC,aAAa,EACbC,UAAU,EACVC,cAAc,EACdC,SAAS,GAEbC,GAAI,CACAC,SAAUpB,gBAGjBqB,MAAK,SAASC,IACXA,GAAGC,GAAGD,GAAGE,OAAOC,OAAOC,eAAeC,OAClCxC,OAASwC,MAAMC,WACXC,UAAYC,OAAOH,MAAMI,KAAKC,SAASC,QAAQ,IAAMxB,KAAKd,UAC9DG,IAAOA,IAAkBoC,KAAKC,IAAIrC,IAAK+B,WAA1BA,UACb/B,IAAMgC,OAAOhC,IAAImC,QAAQ,IACzBxB,KAAKC,YAAciB,MAAMI,KAAKK,YAAYC,MAC1C5B,KAAKX,IAAMA,IACXW,KAAKoB,UAAYC,OAAOD,UAAUI,QAAQ,IAC1CxB,KAAKuB,SAAWvB,KAAKX,IAAMW,KAAKZ,MAChCY,KAAK6B,WAAaX,MAAMI,KAAKQ,WAC7B9B,KAAK+B,UAAYb,MAAMI,KAAKS,UAE5BrD,OAAOsD,uBACHC,OAAS,MACTjC,KAAK6B,WAAWK,OAAS,IACzBlC,KAAK6B,WAAWM,SAASC,QACrBH,OAAOI,KAAK,CACRC,MAAOF,MAAME,MACbC,KAAMH,MAAMI,cAGpBxC,KAAKyC,SAAWR,4CAGN,kBAAmB,CAC7BA,OAAQA,OACRF,UAAW/B,KAAK0C,iBAIhBpD,KAAKqD,SAAU,OACTC,eAAiBC,MAAM,8BAAgChD,SACvDyB,WAAasB,SAASE,WAExBC,KADS,IAAIC,WACAC,gBAAgB3B,KAAM,aACnC4B,MAAO,mBAAEH,KACTI,MAAQD,KAAKE,KAAK,6BAA6BC,KAAK,WACpDC,OAASJ,KAAKE,KAAK,6BAA6BC,KAAK,WACzDrD,KAAKmD,MAAQA,MACbnD,KAAKuD,YAAcD,aAEjB5E,OAAO8E,OAAOpE,aACdV,OAAO+E,QACb1D,OAAQ,sCACM,iBAAkB,KAAML,SAASC,eAAeH,UAElEqB,GAAGC,GAAGD,GAAGE,OAAO2C,MAAMzC,eAAeC,WAC5BnB,aAGLC,KAAK2D,QAAS,EACd3D,KAAK4D,OAAQ,sCACC,0BACKlF,OAAOmF,kBACdxE,MACRW,KAAK4D,OAAQ,EACb5D,KAAK2D,QAAS,sCACA,sBAGtB9C,GAAGC,GAAGD,GAAGE,OAAO+C,OAAO7C,eAAeC,OAC7BnB,QAGLC,KAAK2D,QAAS,sCACA,uBAElB9C,GAAGC,GAAGD,GAAGE,OAAOgD,OAAO,SAAS7C,OACvBnB,QAGLC,KAAK4D,OAAQ,EACb5D,KAAK2D,QAAS,sCACA,sBAElB9C,GAAGC,GAAGD,GAAGE,OAAOiD,YAAY/C,eAAeC,WAClCnB,iBAGDkE,kBAAoBvF,OAAOmF,iBAC3BI,YAAc7E,cACRV,OAAO8E,OAAOpE,OACpBY,KAAK4D,OAAQ,GAEbK,YAAc5E,IAAMW,KAAKd,gBACnBR,OAAO8E,OAAOnE,IAAMW,KAAKd,WAG/B+E,aAAe5E,KACfW,KAAK4D,OAAQ,QACPlF,OAAO8E,OAAOnE,yCACN,mBACNW,KAAK2D,SACb3D,KAAK2D,QAAS,sCACA,wBAGtB9C,GAAGC,GAAGD,GAAGE,OAAOmD,gBAAgBjD,eAAeC,OACtCnB,2CAGS,yBAA0B,CAACf,QAASkC,MAAMlC,aAE5D6B,GAAGC,GAAGD,GAAGE,OAAOoD,oBAAoBlD,eAAeC,OAC1CnB,2CAGS,uBAAwB,CAACqE,KAAMlD,MAAMmD,yBAM9DC,OAAOC,8BAcN,kBAAkBC,KAAK,iCACzBtE,aAAaoE,OAAOnE,mBAfD,KACfsE,IAAM/E,SAASgF,cAAc,UACjCD,IAAIE,IAAM,sDACVF,IAAIxD,OAAQ,EACZwD,IAAIG,GAAK,SACTH,IAAII,IAAM,cACNC,eAAiBpF,SAASqF,qBAAqB,UAAU,GAC7DD,eAAeE,WAAWC,aAAaR,IAAKK,gBAC5CR,OAAOY,0BAA4BjE,eAAed,eAC9CmE,OAAOnE,cAAgBA,cACvBD,aAAaC,oCAafzB,OAAOyG,YACRxB,QAAS,sBAQRjF,OAAO+E,aACRE,QAAS,EAOlByB,KAAKC,WACD3G,OAAO8E,OAAO6B,WACd3G,OAAO+E,QAQX6B,KAAKC,aACGA,KAAO,IACPA,KAAO,QAEN3B,OAAQ,EACblF,OAAO8E,OAAOgC,WAAWD,2CACX,gBAAiB,CAACA,KAAMA,OAC/BA,yCAQM7G,OAAOmF,kDAQGnF,OAAO+G,kCAS1B7F,KAAK+D,cACE,eAEQjF,OAAOgH,gCAStB9F,KAAK+D,cACE,eAEQjF,OAAOgH,8BAWtB9F,KAAKgE,aACE,eAEOlF,OAAOiH,+BAWlB/F,KAAKK,4BAORvB,QACAA,OAAOkH,YACDlH,OAAOmH,0CAEPjG,KAAKJ,OAAQsG,uCASFpH,OAAOgH,WACZ,SAAW,UAQ/BK,QAAQ3B,MACJ1F,OAAOsH,gBAAgB5B,MAK3B6B,OACIvH,OAAOuH,OAKXC,SACIxH,OAAOyH,SACPzH,OAAO0H,UAAU,oBAOJpH,sBACPN,OAAO2H,gBAAgBrH,SACtBA,iCAMH+C,gBAAkBrD,OAAO4H,4BAItB,CACHvE,UAJOA,UAKPwE,eAJSxE,UAAUyE,KAAIC,GAAU,QAALA,EAAc,OAASA,IAKnDC,qBAJgBhI,OAAOiI,2CAYdnE,gBACI,QAAbA,eACM9D,OAAOsD,yBAEPtD,OAAOkI,gBAAgBpE,UAE1BA,SAQXqE,wBACWnI"}